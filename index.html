<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOUGIE-3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 200;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #fileInput {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #fileInput input[type="file"] {
            margin-bottom: 10px;
        }
        #fileInput button {
            background-color: #4CAF50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        #fileInput button:hover {
            background-color: #45a049;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>BOUGIE-3D</h2>
        <div id="hoverInfo">Hover over a XAUUSD candlesticks to see details</div>
    </div>
    <div id="loading">Loading data...</div>
    <div id="fileInput">
        <input type="file" id="csvFile" accept=".csv" />
        <button onclick="loadCSVFile()">Load CSV</button>
        <button onclick="loadMockData()">Load Demo Data</button>
        <div style="margin-top: 5px; font-size: 12px;">
            CSV Format: "time",open,high,low,close,volume<br>
            Example: "2025.05.22,05:15",3340.47,3340.52,3338.80,3338.80,341
        </div>
    </div>
    <div id="controls">
        <ul>
            <li>Left click + drag: Rotate camera</li>
            <li>Right click + drag: Pan camera</li>
            <li>Scroll: Zoom in/out</li>
            <li>Hover over candlestick: View details</li>
        </ul>
        <p>AFLUX Systems - R. Reid - (C) 2025</p>
    </div>

    <!-- Load Three.js directly from CDN -->
    <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        console.log("Script started");
        
        // Mock data for testing
        const mockData = [
            {"date":"2025-04-24T00:10:22.404Z","open":2000,"high":2032.99,"low":1983.06,"close":2032.02,"volume":7015},
            {"date":"2025-04-25T00:10:22.404Z","open":2032.02,"high":2045.70,"low":1984.90,"close":1997.34,"volume":7913},
            {"date":"2025-04-26T00:10:22.404Z","open":1997.34,"high":2004.64,"low":1986.94,"close":1991.09,"volume":13773},
            {"date":"2025-04-29T00:10:22.404Z","open":1991.09,"high":2032.72,"low":1975.62,"close":2014.10,"volume":14911},
            {"date":"2025-04-30T00:10:22.404Z","open":2014.10,"high":2044.37,"low":2011.90,"close":2028.91,"volume":11910},
            {"date":"2025-05-01T00:10:22.404Z","open":2028.91,"high":2061.74,"low":2014.23,"close":2061.17,"volume":12169},
            {"date":"2025-05-02T00:10:22.404Z","open":2061.17,"high":2072.84,"low":2045.87,"close":2055.54,"volume":7974},
            {"date":"2025-05-03T00:10:22.404Z","open":2055.54,"high":2063.83,"low":2039.32,"close":2039.86,"volume":5867},
            {"date":"2025-05-06T00:10:22.404Z","open":2039.86,"high":2057.15,"low":2014.69,"close":2015.02,"volume":8035},
            {"date":"2025-05-07T00:10:22.404Z","open":2015.02,"high":2061.32,"low":2002.37,"close":2053.60,"volume":10205},
            {"date":"2025-05-08T00:10:22.404Z","open":2053.60,"high":2067.98,"low":2001.08,"close":2020.72,"volume":13691},
            {"date":"2025-05-09T00:10:22.404Z","open":2020.72,"high":2029.68,"low":1985.47,"close":1996.95,"volume":8147},
            {"date":"2025-05-10T00:10:22.404Z","open":1996.95,"high":2002.81,"low":1982.72,"close":1987.52,"volume":12438},
            {"date":"2025-05-13T00:10:22.404Z","open":1987.52,"high":1991.37,"low":1962.07,"close":1976.86,"volume":6736},
            {"date":"2025-05-14T00:10:22.404Z","open":1976.86,"high":2019.25,"low":1976.81,"close":2000.94,"volume":8603},
            {"date":"2025-05-15T00:10:22.404Z","open":2000.94,"high":2008.36,"low":1968.98,"close":1986.90,"volume":10998},
            {"date":"2025-05-16T00:10:22.404Z","open":1986.90,"high":2003.62,"low":1970.32,"close":1974.65,"volume":12213},
            {"date":"2025-05-17T00:10:22.404Z","open":1974.65,"high":2001.48,"low":1971.65,"close":1993.55,"volume":6266},
            {"date":"2025-05-20T00:10:22.404Z","open":1993.55,"high":2008.92,"low":1946.72,"close":1964.24,"volume":13114},
            {"date":"2025-05-21T00:10:22.404Z","open":1964.24,"high":1982.42,"low":1954.73,"close":1963.40,"volume":8770},
            {"date":"2025-05-22T00:10:22.404Z","open":1963.40,"high":1999.26,"low":1960.05,"close":1998.54,"volume":9999},
            {"date":"2025-05-23T00:10:22.404Z","open":1998.54,"high":2016.49,"low":1991.05,"close":2008.28,"volume":14505}
        ];

        // Global variables
        let scene, camera, renderer, controls, raycaster, mouse;
        let candlesticks = [];
        let currentData = [];
        
        // Function to parse CSV data
        function parseCSV(csvText) {
            console.log("Parsing CSV data...");
            const lines = csvText.trim().split('\n');
            const data = [];
            
            // Skip header line
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    // Handle CSV parsing with quoted datetime field
                    const parts = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let j = 0; j < line.length; j++) {
                        const char = line[j];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            parts.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    parts.push(current.trim()); // Add the last part
                    
                    if (parts.length >= 6) {
                        // Parse the datetime (format: "2025.05.22,05:15")
                        let dateTimeStr = parts[0].trim();
                        
                        // Remove quotes if present
                        dateTimeStr = dateTimeStr.replace(/"/g, '');
                        
                        // Split by comma to get date and time
                        const dateTimeParts = dateTimeStr.split(',');
                        if (dateTimeParts.length >= 2) {
                            const dateStr = dateTimeParts[0].trim();
                            const timeStr = dateTimeParts[1].trim();
                            
                            // Convert date format from 2025.05.22 to 2025-05-22
                            const formattedDate = dateStr.replace(/\./g, '-');
                            const isoDateTime = `${formattedDate}T${timeStr}:00.000Z`;
                            
                            const candleData = {
                                date: isoDateTime,
                                open: parseFloat(parts[1].trim()),
                                high: parseFloat(parts[2].trim()),
                                low: parseFloat(parts[3].trim()),
                                close: parseFloat(parts[4].trim()),
                                volume: parseInt(parts[5].trim()) || 0
                            };
                            
                            // Validate data
                            if (!isNaN(candleData.open) && !isNaN(candleData.high) && 
                                !isNaN(candleData.low) && !isNaN(candleData.close)) {
                                data.push(candleData);
                            }
                        }
                    }
                }
            }
            
            console.log(`Parsed ${data.length} data points from CSV`);
            return data;
        }
        
        // Function to load CSV file
        function loadCSVFile() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a CSV file first');
                return;
            }
            
            console.log("Loading CSV file:", file.name);
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = 'Loading CSV file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    const data = parseCSV(csvText);
                    
                    if (data.length === 0) {
                        alert('No valid data found in CSV file. Please check the format.');
                        document.getElementById('loading').style.display = 'none';
                        return;
                    }
                    
                    // Clear existing visualization
                    clearVisualization();
                    
                    // Create new visualization
                    currentData = data;
                    createVisualization(data);
                    
                    document.getElementById('loading').style.display = 'none';
                    console.log("CSV data loaded successfully");
                    
                } catch (error) {
                    console.error("Error loading CSV:", error);
                    alert('Error loading CSV file: ' + error.message);
                    document.getElementById('loading').style.display = 'none';
                }
            };
            
            reader.onerror = function() {
                console.error("Error reading file");
                alert('Error reading file');
                document.getElementById('loading').style.display = 'none';
            };
            
            reader.readAsText(file);
        }
        
        // Function to load mock data
        function loadMockData() {
            console.log("Loading mock data...");
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = 'Loading demo data...';
            
            // Clear existing visualization
            clearVisualization();
            
            // Create visualization with mock data
            currentData = mockData;
            createVisualization(mockData);
            
            document.getElementById('loading').style.display = 'none';
            console.log("Mock data loaded successfully");
        }
        
        // Function to clear existing visualization
        function clearVisualization() {
            console.log("Clearing existing visualization...");
            
            // Remove all candlestick objects from scene
            candlesticks.forEach(candlestick => {
                scene.remove(candlestick.wick);
                scene.remove(candlestick.body);
                candlestick.wick.geometry.dispose();
                candlestick.body.geometry.dispose();
                candlestick.wick.material.dispose();
                candlestick.body.material.dispose();
            });
            
            // Clear candlesticks array
            candlesticks = [];
            
            // Remove platform if it exists
            const platform = scene.getObjectByName('platform');
            if (platform) {
                scene.remove(platform);
                platform.geometry.dispose();
                platform.material.dispose();
            }
            
            // Reset info display
            document.getElementById('hoverInfo').textContent = 'Hover over a candlestick to see details';
        }
        
        // Initialize the scene
        function init() {
            console.log("Initializing scene...");
            
            // Check if THREE is available
            if (typeof THREE === 'undefined') {
                console.error("THREE is not defined! Script loading issue.");
                document.getElementById('loading').textContent = 'Error: THREE.js not loaded';
                return;
            }
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 15);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add grid for reference
            const gridHelper = new THREE.GridHelper(50, 50, 0x555555, 0x333333);
            scene.add(gridHelper);
            
            // Add axes for reference
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // Check if OrbitControls is available
            if (typeof THREE.OrbitControls === 'undefined') {
                console.error("THREE.OrbitControls is not defined! Script loading issue.");
                document.getElementById('loading').textContent = 'Error: OrbitControls not loaded';
                return;
            }
            
            // Add orbit controls for interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Setup raycaster for hover interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle mouse move for hover effects
            window.addEventListener('mousemove', onMouseMove);
            
            // Use mock data initially
            console.log("Using mock data initially");
            currentData = mockData;
            createVisualization(mockData);
            
            // Hide loading message
            document.getElementById('loading').style.display = 'none';
            
            // Start animation loop
            animate();
        }
        
        // Create 3D visualization from stock data
        function createVisualization(data) {
            console.log("Creating visualization with data:", data);
            
            // Find min and max values for scaling
            let minPrice = Infinity;
            let maxPrice = -Infinity;
            let minVolume = Infinity;
            let maxVolume = -Infinity;
            
            data.forEach(day => {
                minPrice = Math.min(minPrice, day.low);
                maxPrice = Math.max(maxPrice, day.high);
                minVolume = Math.min(minVolume, day.volume);
                maxVolume = Math.max(maxVolume, day.volume);
            });
            
            console.log("Price range:", minPrice, "to", maxPrice);
            console.log("Volume range:", minVolume, "to", maxVolume);
            
            // Create base platform
            const platformGeometry = new THREE.BoxGeometry(data.length + 2, 0.5, 15);
            const platformMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(data.length / 2 - 0.5, -0.25, 0);
            platform.receiveShadow = true;
            platform.name = 'platform'; // Add name for easy removal
            scene.add(platform);
            
            // Create candlesticks
            data.forEach((day, index) => {
                // Normalize price values
                const priceRange = maxPrice - minPrice;
                const normalizedOpen = ((day.open - minPrice) / priceRange) * 10;
                const normalizedClose = ((day.close - minPrice) / priceRange) * 10;
                const normalizedHigh = ((day.high - minPrice) / priceRange) * 10;
                const normalizedLow = ((day.low - minPrice) / priceRange) * 10;
                
                // Normalize volume
                const volumeRange = maxVolume - minVolume;
                const normalizedVolume = ((day.volume - minVolume) / volumeRange) * 3 + 0.5;
                
                // Create candlestick
                const isUp = day.close >= day.open;
                const candleColor = isUp ? 0x00ff00 : 0xff0000;
                
                // Create wick (vertical line)
                const wickGeometry = new THREE.CylinderGeometry(0.05, 0.05, normalizedHigh - normalizedLow, 8);
                const wickMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                const wick = new THREE.Mesh(wickGeometry, wickMaterial);
                wick.position.set(index, (normalizedHigh + normalizedLow) / 2, 0);
                wick.castShadow = true;
                scene.add(wick);
                
                // Create body (box)
                const bodyHeight = Math.abs(normalizedClose - normalizedOpen);
                const bodyGeometry = new THREE.BoxGeometry(0.6, bodyHeight, normalizedVolume);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: candleColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                // Position body
                const bodyY = isUp ? 
                    (normalizedOpen + bodyHeight / 2) : 
                    (normalizedClose + bodyHeight / 2);
                body.position.set(index, bodyY, 0);
                body.castShadow = true;
                scene.add(body);
                
                // Store reference to candlestick for interaction
                candlesticks.push({
                    wick: wick,
                    body: body,
                    data: day
                });
            });
            
            // Position camera to view all candlesticks
            camera.position.set(data.length / 2 - 0.5, 10, 20);
            controls.target.set(data.length / 2 - 0.5, 5, 0);
            controls.update();
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle mouse move for hover effects
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        // Check for intersections with candlesticks
        function checkIntersections() {
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Collect all meshes for intersection test
            const meshes = candlesticks.flatMap(candlestick => [candlestick.wick, candlestick.body]);
            
            // Calculate intersections
            const intersects = raycaster.intersectObjects(meshes);
            
            // Reset all candlesticks to original appearance
            candlesticks.forEach(candlestick => {
                const isUp = candlestick.data.close >= candlestick.data.open;
                candlestick.body.material.color.setHex(isUp ? 0x00ff00 : 0xff0000);
                candlestick.body.material.opacity = 1;
                candlestick.wick.material.color.setHex(0xcccccc);
            });
            
            // Update hover info text
            const hoverInfoElement = document.getElementById('hoverInfo');
            
            if (intersects.length > 0) {
                // Find which candlestick was intersected
                const intersectedMesh = intersects[0].object;
                const candlestick = candlesticks.find(c => 
                    c.wick === intersectedMesh || c.body === intersectedMesh
                );
                
                if (candlestick) {
                    // Highlight the intersected candlestick
                    candlestick.body.material.color.setHex(0xffff00);
                    candlestick.wick.material.color.setHex(0xffff00);
                    
                    // Format date
                    const date = new Date(candlestick.data.date);
                    const dateStr = date.toLocaleDateString();
                    const timeStr = date.toLocaleTimeString();
                    
                    // Update info text
                    hoverInfoElement.innerHTML = `
                        <strong>Date:</strong> ${dateStr} ${timeStr}<br>
                        <strong>Open:</strong> $${candlestick.data.open.toFixed(2)}<br>
                        <strong>High:</strong> $${candlestick.data.high.toFixed(2)}<br>
                        <strong>Low:</strong> $${candlestick.data.low.toFixed(2)}<br>
                        <strong>Close:</strong> $${candlestick.data.close.toFixed(2)}<br>
                        <strong>Volume:</strong> ${candlestick.data.volume.toLocaleString()}
                    `;
                }
            } else {
                // Reset info text when not hovering over any candlestick
                hoverInfoElement.textContent = 'Hover over a candlestick to see details';
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Check for intersections
            checkIntersections();
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Initialize immediately
        console.log("Starting initialization...");
        window.onload = function() {
            console.log("Window loaded, initializing...");
            init();
        };
    </script>
</body>
</html>