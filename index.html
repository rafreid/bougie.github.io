<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOUGIE-3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 200;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #fileInput {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #fileInput input[type="file"] {
            margin-bottom: 10px;
        }
        #fileInput button {
            background-color: #4CAF50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        #fileInput button:hover {
            background-color: #45a049;
        }
        #scrollControls {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #scrollControls button {
            background-color: #2196F3;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
            display: block;
            width: 100%;
            font-size: 14px;
        }
        #scrollControls button:hover {
            background-color: #1976D2;
        }
        #scrollControls button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #timeframeControls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #timeframeControls button {
            background-color: #FF9800;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            font-size: 12px;
        }
        #timeframeControls button:hover {
            background-color: #F57C00;
        }
        #timeframeControls button.active {
            background-color: #4CAF50;
        }
        #timeframeControls button.active:hover {
            background-color: #45a049;
        }
        #patternControls {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 150px;
        }
        #patternControls button {
            background-color: #9C27B0;
            color: white;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px 0;
            display: block;
            width: 100%;
            font-size: 11px;
        }
        #patternControls button:hover {
            background-color: #7B1FA2;
        }
        #patternControls button.active {
            background-color: #4CAF50;
        }
        #patternControls button.active:hover {
            background-color: #45a049;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>BOUGIE-3D</h2>
        <div id="hoverInfo">Hover over a XAUUSD candlesticks to see details</div>
        <div id="cameraInfo" style="margin-top: 10px; font-size: 12px; color: #aaa;">
            <strong>Camera Position:</strong> X: <span id="camX">0.00</span> | Y: <span id="camY">0.00</span> | Z: <span id="camZ">0.00</span><br>
            <strong>Cursor Position:</strong> X: <span id="cursorX">0.00</span> | Y: <span id="cursorY">0.00</span>
        </div>
    </div>
    <div id="loading">Loading data...</div>
    <div id="fileInput">
        <input type="file" id="csvFile" accept=".csv" />
        <button onclick="loadCSVFile()">Load CSV</button>
        <button onclick="loadMockData()">Load Demo Data</button>
        <div style="margin-top: 5px; font-size: 12px;">
            CSV Format: "time",open,high,low,close,volume<br>
            Example: "2025.05.22,05:15",3340.47,3340.52,3338.80,3338.80,341
        </div>
    </div>
    <div id="patternControls">
        <div style="margin-bottom: 5px; font-size: 12px; text-align: center; color: #ccc;">
            Pattern Detection
        </div>
        <button onclick="togglePatternDetection()" id="patternToggle" class="active">Enable Patterns</button>
        <div style="margin: 8px 0; font-size: 10px; color: #888;">
            Detected Patterns:
        </div>
        <button onclick="togglePattern('doji')" id="pattern-doji" class="active">Doji</button>
        <button onclick="togglePattern('hammer')" id="pattern-hammer" class="active">Hammer</button>
        <button onclick="togglePattern('engulfing')" id="pattern-engulfing" class="active">Engulfing</button>
        <button onclick="togglePattern('morningstar')" id="pattern-morningstar" class="active">Morning Star</button>
        <button onclick="togglePattern('eveningstar')" id="pattern-eveningstar" class="active">Evening Star</button>
    </div>
    <div id="scrollControls">
        <button onclick="scrollDataLeft()" id="scrollLeftBtn">◀ Scroll Left</button>
        <button onclick="scrollDataRight()" id="scrollRightBtn">Scroll Right ▶</button>
        <button onclick="resetCamera()" id="resetCameraBtn" style="margin-top: 10px;">Reset Camera</button>
        <div style="margin-top: 10px; font-size: 12px; text-align: center; color: #ccc;">
            Navigate Data
        </div>
    </div>
    <div id="timeframeControls">
        <div style="margin-bottom: 5px; font-size: 12px; text-align: center; color: #ccc;">
            Timeframes
        </div>
        <button onclick="setTimeframe('1m')" id="tf-1m">1m</button>
        <button onclick="setTimeframe('5m')" id="tf-5m" class="active">5m</button>
        <button onclick="setTimeframe('15m')" id="tf-15m">15m</button>
        <button onclick="setTimeframe('1h')" id="tf-1h">1h</button>
        <button onclick="setTimeframe('4h')" id="tf-4h">4h</button>
        <button onclick="setTimeframe('1D')" id="tf-1D">1D</button>
    </div>
    <div id="controls">
        <ul>
            <li>Left click + drag: Rotate camera</li>
            <li>Right click + drag: Pan camera</li>
            <li>Scroll: Zoom in/out</li>
            <li>Hover over candlestick: View details</li>
            <li>Arrow keys: Navigate data left/right</li>
        </ul>
        <p>AFLUX Systems LLC - R. Reid - (C) 2025</p>
    </div>

    <!-- Load Three.js directly from CDN -->
    <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        console.log("Script started");
        
        // Mock data for testing
        const mockData = [
            {"date":"2025-04-24T00:10:22.404Z","open":2000,"high":2032.99,"low":1983.06,"close":2032.02,"volume":7015},
            {"date":"2025-04-25T00:10:22.404Z","open":2032.02,"high":2045.70,"low":1984.90,"close":1997.34,"volume":7913},
            {"date":"2025-04-26T00:10:22.404Z","open":1997.34,"high":2004.64,"low":1986.94,"close":1991.09,"volume":13773},
            {"date":"2025-04-29T00:10:22.404Z","open":1991.09,"high":2032.72,"low":1975.62,"close":2014.10,"volume":14911},
            {"date":"2025-04-30T00:10:22.404Z","open":2014.10,"high":2044.37,"low":2011.90,"close":2028.91,"volume":11910},
            {"date":"2025-05-01T00:10:22.404Z","open":2028.91,"high":2061.74,"low":2014.23,"close":2061.17,"volume":12169},
            {"date":"2025-05-02T00:10:22.404Z","open":2061.17,"high":2072.84,"low":2045.87,"close":2055.54,"volume":7974},
            {"date":"2025-05-03T00:10:22.404Z","open":2055.54,"high":2063.83,"low":2039.32,"close":2039.86,"volume":5867},
            {"date":"2025-05-06T00:10:22.404Z","open":2039.86,"high":2057.15,"low":2014.69,"close":2015.02,"volume":8035},
            {"date":"2025-05-07T00:10:22.404Z","open":2015.02,"high":2061.32,"low":2002.37,"close":2053.60,"volume":10205},
            {"date":"2025-05-08T00:10:22.404Z","open":2053.60,"high":2067.98,"low":2001.08,"close":2020.72,"volume":13691},
            {"date":"2025-05-09T00:10:22.404Z","open":2020.72,"high":2029.68,"low":1985.47,"close":1996.95,"volume":8147},
            {"date":"2025-05-10T00:10:22.404Z","open":1996.95,"high":2002.81,"low":1982.72,"close":1987.52,"volume":12438},
            {"date":"2025-05-13T00:10:22.404Z","open":1987.52,"high":1991.37,"low":1962.07,"close":1976.86,"volume":6736},
            {"date":"2025-05-14T00:10:22.404Z","open":1976.86,"high":2019.25,"low":1976.81,"close":2000.94,"volume":8603},
            {"date":"2025-05-15T00:10:22.404Z","open":2000.94,"high":2008.36,"low":1968.98,"close":1986.90,"volume":10998},
            {"date":"2025-05-16T00:10:22.404Z","open":1986.90,"high":2003.62,"low":1970.32,"close":1974.65,"volume":12213},
            {"date":"2025-05-17T00:10:22.404Z","open":1974.65,"high":2001.48,"low":1971.65,"close":1993.55,"volume":6266},
            {"date":"2025-05-20T00:10:22.404Z","open":1993.55,"high":2008.92,"low":1946.72,"close":1964.24,"volume":13114},
            {"date":"2025-05-21T00:10:22.404Z","open":1964.24,"high":1982.42,"low":1954.73,"close":1963.40,"volume":8770},
            {"date":"2025-05-22T00:10:22.404Z","open":1963.40,"high":1999.26,"low":1960.05,"close":1998.54,"volume":9999},
            {"date":"2025-05-23T00:10:22.404Z","open":1998.54,"high":2016.49,"low":1991.05,"close":2008.28,"volume":14505}
        ];

        // Global variables
        let scene, camera, renderer, controls, raycaster, mouse;
        let candlesticks = [];
        let currentData = [];
        let rawData = []; // Store original unfiltered data
        let scrollOffset = 0; // Track the current scroll position
        let currentTimeframe = '5m'; // Default timeframe
        let patternDetectionEnabled = true;
        let enabledPatterns = {
            doji: true,
            hammer: true,
            engulfing: true,
            morningstar: true,
            eveningstar: true
        };
        let detectedPatterns = []; // Store detected patterns
        
        // Scroll functions
        function scrollDataLeft() {
            console.log("Scroll left clicked, current offset:", scrollOffset);
            if (scrollOffset > 0) {
                scrollOffset--;
                console.log("New offset:", scrollOffset);
                updateCandlestickPositions();
                updateScrollButtons();
            } else {
                console.log("Cannot scroll left further");
            }
        }
        
        function scrollDataRight() {
            console.log("Scroll right clicked, current offset:", scrollOffset);
            if (scrollOffset < currentData.length - 1) {
                scrollOffset++;
                console.log("New offset:", scrollOffset);
                updateCandlestickPositions();
                updateScrollButtons();
            } else {
                console.log("Cannot scroll right further");
            }
        }
        
        function updateCandlestickPositions() {
            console.log("Updating positions with offset:", scrollOffset);
            candlesticks.forEach((candlestick, index) => {
                const newX = index - scrollOffset;
                candlestick.wick.position.x = newX;
                candlestick.body.position.x = newX;
            });
            
            // Update camera target to follow the center of visible candlesticks
            const centerX = (currentData.length - 1) / 2 - scrollOffset;
            controls.target.set(centerX, 5, 0);
            controls.update();
        }
        
        function updateScrollButtons() {
            const leftBtn = document.getElementById('scrollLeftBtn');
            const rightBtn = document.getElementById('scrollRightBtn');
            
            console.log("Updating button states - offset:", scrollOffset, "data length:", currentData.length);
            
            if (leftBtn && rightBtn) {
                const canScrollLeft = scrollOffset > 0;
                const canScrollRight = scrollOffset < currentData.length - 1;
                
                leftBtn.disabled = !canScrollLeft;
                rightBtn.disabled = !canScrollRight;
                
                console.log("Left button enabled:", canScrollLeft, "Right button enabled:", canScrollRight);
            } else {
                console.log("Buttons not found!");
            }
        }
        
        // Function to reset camera position
        function resetCamera() {
            if (camera && controls) {
                camera.position.set(10, 5, 25);
                controls.update();
            }
        }
        
        // Function to set timeframe
        function setTimeframe(timeframe) {
            console.log("Setting timeframe to:", timeframe);
            currentTimeframe = timeframe;
            
            // Update button states
            updateTimeframeButtons();
            
            // Process data for the selected timeframe
            if (rawData.length > 0) {
                const processedData = processTimeframeData(rawData, timeframe);
                currentData = processedData;
                
                // Clear and recreate visualization
                clearVisualization();
                createVisualization(processedData);
            }
        }
        
        // Function to update timeframe button states
        function updateTimeframeButtons() {
            const timeframes = ['1m', '5m', '15m', '1h', '4h', '1D'];
            timeframes.forEach(tf => {
                const button = document.getElementById(`tf-${tf}`);
                if (button) {
                    if (tf === currentTimeframe) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                }
            });
        }
        
        // Function to process data for different timeframes
        function processTimeframeData(data, timeframe) {
            if (!data || data.length === 0) return [];
            
            // Sort data by date to ensure proper chronological order
            const sortedData = [...data].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Define timeframe intervals in minutes
            const intervals = {
                '1m': 1,
                '5m': 5,
                '15m': 15,
                '1h': 60,
                '4h': 240,
                '1D': 1440
            };
            
            const intervalMinutes = intervals[timeframe];
            if (!intervalMinutes) return sortedData;
            
            // Group data by timeframe intervals
            const groupedData = {};
            
            sortedData.forEach(candle => {
                const date = new Date(candle.date);
                
                // Round down to the nearest interval
                const intervalStart = new Date(date);
                if (timeframe === '1D') {
                    intervalStart.setHours(0, 0, 0, 0);
                } else {
                    const minutes = intervalStart.getMinutes();
                    const roundedMinutes = Math.floor(minutes / intervalMinutes) * intervalMinutes;
                    intervalStart.setMinutes(roundedMinutes, 0, 0);
                }
                
                const key = intervalStart.getTime();
                
                if (!groupedData[key]) {
                    groupedData[key] = {
                        date: intervalStart.toISOString(),
                        open: candle.open,
                        high: candle.high,
                        low: candle.low,
                        close: candle.close,
                        volume: candle.volume,
                        count: 1
                    };
                } else {
                    // Aggregate OHLCV data
                    groupedData[key].high = Math.max(groupedData[key].high, candle.high);
                    groupedData[key].low = Math.min(groupedData[key].low, candle.low);
                    groupedData[key].close = candle.close; // Last close becomes the close
                    groupedData[key].volume += candle.volume;
                    groupedData[key].count++;
                }
            });
            
            // Convert back to array and sort by date
            const result = Object.values(groupedData).sort((a, b) => new Date(a.date) - new Date(b.date));
            
            console.log(`Processed ${sortedData.length} candles into ${result.length} ${timeframe} candles`);
            return result;
        }
        
        // Candlestick Pattern Recognition Functions
        function detectPatterns(data) {
            if (!patternDetectionEnabled || !data || data.length < 3) return [];
            
            const patterns = [];
            
            for (let i = 2; i < data.length; i++) {
                const prev2 = data[i - 2];
                const prev1 = data[i - 1];
                const current = data[i];
                
                // Detect various patterns
                if (enabledPatterns.doji && isDoji(current)) {
                    patterns.push({ index: i, type: 'doji', name: 'Doji', color: 0xFFEB3B });
                }
                
                if (enabledPatterns.hammer && isHammer(current)) {
                    patterns.push({ index: i, type: 'hammer', name: 'Hammer', color: 0x00BCD4 });
                }
                
                if (enabledPatterns.engulfing && isBullishEngulfing(prev1, current)) {
                    patterns.push({ index: i, type: 'engulfing', name: 'Bullish Engulfing', color: 0x4CAF50 });
                } else if (enabledPatterns.engulfing && isBearishEngulfing(prev1, current)) {
                    patterns.push({ index: i, type: 'engulfing', name: 'Bearish Engulfing', color: 0xF44336 });
                }
                
                if (enabledPatterns.morningstar && isMorningStar(prev2, prev1, current)) {
                    patterns.push({ index: i, type: 'morningstar', name: 'Morning Star', color: 0x03A9F4 });
                }
                
                if (enabledPatterns.eveningstar && isEveningStar(prev2, prev1, current)) {
                    patterns.push({ index: i, type: 'eveningstar', name: 'Evening Star', color: 0xFF5722 });
                }
            }
            
            console.log(`Detected ${patterns.length} patterns`);
            return patterns;
        }
        
        // Pattern detection helper functions
        function isDoji(candle) {
            const bodySize = Math.abs(candle.close - candle.open);
            const totalRange = candle.high - candle.low;
            return totalRange > 0 && (bodySize / totalRange) < 0.1;
        }
        
        function isHammer(candle) {
            const bodySize = Math.abs(candle.close - candle.open);
            const lowerShadow = Math.min(candle.open, candle.close) - candle.low;
            const upperShadow = candle.high - Math.max(candle.open, candle.close);
            const totalRange = candle.high - candle.low;
            
            return totalRange > 0 && 
                   lowerShadow > (bodySize * 2) && 
                   upperShadow < (bodySize * 0.5) &&
                   bodySize > 0;
        }
        
        function isBullishEngulfing(prev, current) {
            return prev.close < prev.open && // Previous is bearish
                   current.close > current.open && // Current is bullish
                   current.open < prev.close && // Current opens below previous close
                   current.close > prev.open; // Current closes above previous open
        }
        
        function isBearishEngulfing(prev, current) {
            return prev.close > prev.open && // Previous is bullish
                   current.close < current.open && // Current is bearish
                   current.open > prev.close && // Current opens above previous close
                   current.close < prev.open; // Current closes below previous open
        }
        
        function isMorningStar(first, second, third) {
            const firstBearish = first.close < first.open;
            const secondSmall = Math.abs(second.close - second.open) < Math.abs(first.close - first.open) * 0.3;
            const thirdBullish = third.close > third.open;
            const gapDown = second.high < first.close;
            const gapUp = third.open > second.high;
            
            return firstBearish && secondSmall && thirdBullish && gapDown && gapUp;
        }
        
        function isEveningStar(first, second, third) {
            const firstBullish = first.close > first.open;
            const secondSmall = Math.abs(second.close - second.open) < Math.abs(first.close - first.open) * 0.3;
            const thirdBearish = third.close < third.open;
            const gapUp = second.low > first.close;
            const gapDown = third.open < second.low;
            
            return firstBullish && secondSmall && thirdBearish && gapUp && gapDown;
        }
        
        // Pattern control functions
        function togglePatternDetection() {
            patternDetectionEnabled = !patternDetectionEnabled;
            const button = document.getElementById('patternToggle');
            if (button) {
                button.textContent = patternDetectionEnabled ? 'Enable Patterns' : 'Disable Patterns';
                button.classList.toggle('active', patternDetectionEnabled);
            }
            
            // Recreate visualization to update patterns
            if (currentData.length > 0) {
                clearVisualization();
                createVisualization(currentData);
            }
        }
        
        function togglePattern(patternType) {
            enabledPatterns[patternType] = !enabledPatterns[patternType];
            const button = document.getElementById(`pattern-${patternType}`);
            if (button) {
                button.classList.toggle('active', enabledPatterns[patternType]);
            }
            
            // Recreate visualization to update patterns
            if (currentData.length > 0) {
                clearVisualization();
                createVisualization(currentData);
            }
        }
        
        // Function to update camera coordinates display
        function updateCameraDisplay() {
            const camX = document.getElementById('camX');
            const camY = document.getElementById('camY');
            const camZ = document.getElementById('camZ');
            const cursorX = document.getElementById('cursorX');
            const cursorY = document.getElementById('cursorY');
            
            if (camera) {
                if (camX) camX.textContent = camera.position.x.toFixed(2);
                if (camY) camY.textContent = camera.position.y.toFixed(2);
                if (camZ) camZ.textContent = camera.position.z.toFixed(2);
            }
            
            if (cursorX) cursorX.textContent = mouse.x.toFixed(2);
            if (cursorY) cursorY.textContent = mouse.y.toFixed(2);
        }
        
        // Function to parse CSV data
        function parseCSV(csvText) {
            console.log("Parsing CSV data...");
            const lines = csvText.trim().split('\n');
            const data = [];
            
            // Skip header line
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    // Handle CSV parsing with quoted datetime field
                    const parts = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let j = 0; j < line.length; j++) {
                        const char = line[j];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            parts.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    parts.push(current.trim()); // Add the last part
                    
                    if (parts.length >= 6) {
                        // Parse the datetime (format: "2025.05.22,05:15")
                        let dateTimeStr = parts[0].trim();
                        
                        // Remove quotes if present
                        dateTimeStr = dateTimeStr.replace(/"/g, '');
                        
                        // Split by comma to get date and time
                        const dateTimeParts = dateTimeStr.split(',');
                        if (dateTimeParts.length >= 2) {
                            const dateStr = dateTimeParts[0].trim();
                            const timeStr = dateTimeParts[1].trim();
                            
                            // Convert date format from 2025.05.22 to 2025-05-22
                            const formattedDate = dateStr.replace(/\./g, '-');
                            const isoDateTime = `${formattedDate}T${timeStr}:00.000Z`;
                            
                            const candleData = {
                                date: isoDateTime,
                                open: parseFloat(parts[1].trim()),
                                high: parseFloat(parts[2].trim()),
                                low: parseFloat(parts[3].trim()),
                                close: parseFloat(parts[4].trim()),
                                volume: parseInt(parts[5].trim()) || 0
                            };
                            
                            // Validate data
                            if (!isNaN(candleData.open) && !isNaN(candleData.high) && 
                                !isNaN(candleData.low) && !isNaN(candleData.close)) {
                                data.push(candleData);
                            }
                        }
                    }
                }
            }
            
            console.log(`Parsed ${data.length} data points from CSV`);
            return data;
        }
        
        // Function to load CSV file
        function loadCSVFile() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a CSV file first');
                return;
            }
            
            console.log("Loading CSV file:", file.name);
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = 'Loading CSV file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    const data = parseCSV(csvText);
                    
                    if (data.length === 0) {
                        alert('No valid data found in CSV file. Please check the format.');
                        document.getElementById('loading').style.display = 'none';
                        return;
                    }
                    
                    // Clear existing visualization
                    clearVisualization();
                    
                    // Store raw data and process for current timeframe
                    rawData = data;
                    const processedData = processTimeframeData(data, currentTimeframe);
                    currentData = processedData;
                    
                    // Create new visualization
                    createVisualization(processedData);
                    
                    document.getElementById('loading').style.display = 'none';
                    console.log("CSV data loaded successfully");
                    
                } catch (error) {
                    console.error("Error loading CSV:", error);
                    alert('Error loading CSV file: ' + error.message);
                    document.getElementById('loading').style.display = 'none';
                }
            };
            
            reader.onerror = function() {
                console.error("Error reading file");
                alert('Error reading file');
                document.getElementById('loading').style.display = 'none';
            };
            
            reader.readAsText(file);
        }
        
        // Function to load mock data
        function loadMockData() {
            console.log("Loading mock data...");
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = 'Loading demo data...';
            
            // Clear existing visualization
            clearVisualization();
            
            // Store raw data and process for current timeframe
            rawData = mockData;
            const processedData = processTimeframeData(mockData, currentTimeframe);
            currentData = processedData;
            
            // Create visualization with processed data
            createVisualization(processedData);
            
            document.getElementById('loading').style.display = 'none';
            console.log("Mock data loaded successfully");
        }
        
        // Function to clear existing visualization
        function clearVisualization() {
            console.log("Clearing existing visualization...");
            
            // Remove all candlestick objects from scene
            candlesticks.forEach(candlestick => {
                scene.remove(candlestick.wick);
                scene.remove(candlestick.body);
                if (candlestick.indicator) {
                    scene.remove(candlestick.indicator);
                    candlestick.indicator.geometry.dispose();
                    candlestick.indicator.material.dispose();
                }
                candlestick.wick.geometry.dispose();
                candlestick.body.geometry.dispose();
                candlestick.wick.material.dispose();
                candlestick.body.material.dispose();
            });
            
            // Clear arrays
            candlesticks = [];
            detectedPatterns = [];
            
            // Reset scroll offset
            scrollOffset = 0;
            
            // Remove platform if it exists
            const platform = scene.getObjectByName('platform');
            if (platform) {
                scene.remove(platform);
                platform.geometry.dispose();
                platform.material.dispose();
            }
            
            // Reset info display
            document.getElementById('hoverInfo').textContent = 'Hover over a candlestick to see details';
        }
        
        // Initialize the scene
        function init() {
            console.log("Initializing scene...");
            
            // Check if THREE is available
            if (typeof THREE === 'undefined') {
                console.error("THREE is not defined! Script loading issue.");
                document.getElementById('loading').textContent = 'Error: THREE.js not loaded';
                return;
            }
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 15);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add grid for reference
            const gridHelper = new THREE.GridHelper(50, 50, 0x555555, 0x333333);
            scene.add(gridHelper);

            // Add grid for reference
            const gridHelper2 = new THREE.GridHelper(50, 50, 0x555555, 0x333333);
            gridHelper.rotation.x=Math.PI/2;
            scene.add(gridHelper2);
            
            // Add axes for reference
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // Check if OrbitControls is available
            if (typeof THREE.OrbitControls === 'undefined') {
                console.error("THREE.OrbitControls is not defined! Script loading issue.");
                document.getElementById('loading').textContent = 'Error: OrbitControls not loaded';
                return;
            }
            
            // Add orbit controls for interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Setup raycaster for hover interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle mouse move for hover effects
            window.addEventListener('mousemove', onMouseMove);
            
            // Handle keyboard events for scrolling
            window.addEventListener('keydown', onKeyDown);
            
            // Use mock data initially
            console.log("Using mock data initially");
            rawData = mockData;
            const processedData = processTimeframeData(mockData, currentTimeframe);
            currentData = processedData;
            createVisualization(processedData);
            
            // Hide loading message
            document.getElementById('loading').style.display = 'none';
            
            // Start animation loop
            animate();
        }
        
        // Create 3D visualization from stock data
        function createVisualization(data) {
            console.log("Creating visualization with data:", data);
            
            // Detect patterns before creating visualization
            detectedPatterns = detectPatterns(data);
            
            // Find min and max values for scaling
            let minPrice = Infinity;
            let maxPrice = -Infinity;
            let minVolume = Infinity;
            let maxVolume = -Infinity;
            
            data.forEach(day => {
                minPrice = Math.min(minPrice, day.low);
                maxPrice = Math.max(maxPrice, day.high);
                minVolume = Math.min(minVolume, day.volume);
                maxVolume = Math.max(maxVolume, day.volume);
            });
            
            console.log("Price range:", minPrice, "to", maxPrice);
            console.log("Volume range:", minVolume, "to", maxVolume);
            
            // Create base platform
            // const platformGeometry = new THREE.BoxGeometry(data.length + 2, 0.5, 15);
            // const platformMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            // const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            // platform.position.set(data.length / 2 - 0.5, -0.25, 0);
            // platform.receiveShadow = true;
            // platform.name = 'platform'; // Add name for easy removal
            // scene.add(platform);
            
            // Create candlesticks
            data.forEach((day, index) => {
                // Normalize price values
                const priceRange = maxPrice - minPrice;
                const normalizedOpen = ((day.open - minPrice) / priceRange) * 10;
                const normalizedClose = ((day.close - minPrice) / priceRange) * 10;
                const normalizedHigh = ((day.high - minPrice) / priceRange) * 10;
                const normalizedLow = ((day.low - minPrice) / priceRange) * 10;
                
                // Normalize volume
                const volumeRange = maxVolume - minVolume;
                const normalizedVolume = ((day.volume - minVolume) / volumeRange) * 3 + 0.5;
                
                // Check if this candlestick has a pattern
                const pattern = detectedPatterns.find(p => p.index === index);
                
                // Create candlestick
                const isUp = day.close >= day.open;
                let candleColor = isUp ? 0x00ff00 : 0xff0000;
                
                // Override color if pattern detected
                if (pattern && patternDetectionEnabled) {
                    candleColor = pattern.color;
                }
                
                // Create wick (vertical line)
                const wickGeometry = new THREE.CylinderGeometry(0.05, 0.05, normalizedHigh - normalizedLow, 8);
                const wickMaterial = new THREE.MeshPhongMaterial({ 
                    color: pattern && patternDetectionEnabled ? pattern.color : 0xcccccc 
                });
                const wick = new THREE.Mesh(wickGeometry, wickMaterial);
                wick.position.set(index, (normalizedHigh + normalizedLow) / 2, 0);
                wick.castShadow = true;
                scene.add(wick);
                
                // Create body (box)
                const bodyHeight = Math.abs(normalizedClose - normalizedOpen);
                const bodyGeometry = new THREE.BoxGeometry(0.6, bodyHeight, normalizedVolume);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: candleColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                // Position body
                const bodyY = isUp ? 
                    (normalizedOpen + bodyHeight / 2) : 
                    (normalizedClose + bodyHeight / 2);
                body.position.set(index, bodyY, 0);
                body.castShadow = true;
                scene.add(body);
                
                // Add pattern indicator above candlestick if pattern detected
                if (pattern && patternDetectionEnabled) {
                    const textGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const textMaterial = new THREE.MeshPhongMaterial({ 
                        color: pattern.color,
                        emissive: pattern.color,
                        emissiveIntensity: 0.3
                    });
                    const indicator = new THREE.Mesh(textGeometry, textMaterial);
                    indicator.position.set(index, normalizedHigh + 1, 0);
                    scene.add(indicator);
                    
                    // Store pattern info with candlestick
                    candlesticks.push({
                        wick: wick,
                        body: body,
                        indicator: indicator,
                        data: day,
                        pattern: pattern
                    });
                } else {
                    // Store reference to candlestick for interaction
                    candlesticks.push({
                        wick: wick,
                        body: body,
                        data: day
                    });
                }
            });
            
            // Position camera to view all candlesticks
            camera.position.set(data.length / 2 - 0.5, 10, 20);
            controls.target.set(data.length / 2 - 0.5, 5, 0);
            controls.update();
            
            // Initialize scroll buttons
            updateScrollButtons();
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle mouse move for hover effects
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        // Handle keyboard events for scrolling
        function onKeyDown(event) {
            switch(event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    scrollDataLeft();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    scrollDataRight();
                    break;
            }
        }
        
        // Check for intersections with candlesticks
        function checkIntersections() {
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Collect all meshes for intersection test
            const meshes = candlesticks.flatMap(candlestick => [candlestick.wick, candlestick.body]);
            
            // Calculate intersections
            const intersects = raycaster.intersectObjects(meshes);
            
            // Reset all candlesticks to original appearance
            candlesticks.forEach(candlestick => {
                const isUp = candlestick.data.close >= candlestick.data.open;
                candlestick.body.material.color.setHex(isUp ? 0x00ff00 : 0xff0000);
                candlestick.body.material.opacity = 1;
                candlestick.wick.material.color.setHex(0xcccccc);
            });
            
            // Update hover info text
            const hoverInfoElement = document.getElementById('hoverInfo');
            
            if (intersects.length > 0) {
                // Find which candlestick was intersected
                const intersectedMesh = intersects[0].object;
                const candlestick = candlesticks.find(c => 
                    c.wick === intersectedMesh || c.body === intersectedMesh
                );
                
                if (candlestick) {
                    // Highlight the intersected candlestick
                    candlestick.body.material.color.setHex(0xffff00);
                    candlestick.wick.material.color.setHex(0xffff00);
                    
                    // Format date
                    const date = new Date(candlestick.data.date);
                    const dateStr = date.toLocaleDateString();
                    const timeStr = date.toLocaleTimeString();
                    
                    hoverInfoElement.style.color = candlestick.data.open.toFixed(2) < candlestick.data.close.toFixed(2) ? "green" : "red";

                    // Update info text
                    hoverInfoElement.innerHTML = `
                        <strong>Date:</strong> ${dateStr} ${timeStr}<br>
                        <strong>Open:</strong> ${candlestick.data.open.toFixed(2)}<br>
                        <strong>High:</strong> ${candlestick.data.high.toFixed(2)}<br>
                        <strong>Low:</strong> ${candlestick.data.low.toFixed(2)}<br>
                        <strong>Close:</strong> ${candlestick.data.close.toFixed(2)}<br>
                        <strong>Volume:</strong> ${candlestick.data.volume.toLocaleString()}${candlestick.pattern ? `<br><strong style="color: ${candlestick.pattern.color === 0xFFEB3B ? '#FFEB3B' : candlestick.pattern.color === 0x00BCD4 ? '#00BCD4' : candlestick.pattern.color === 0x4CAF50 ? '#4CAF50' : candlestick.pattern.color === 0xF44336 ? '#F44336' : candlestick.pattern.color === 0x03A9F4 ? '#03A9F4' : '#FF5722'};">Pattern: ${candlestick.pattern.name}</strong>` : ''}
                    `;
                }
            } else {
                // Reset info text when not hovering over any candlestick
                hoverInfoElement.textContent = 'Hover over a candlestick to see details';
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Update camera coordinates display
            updateCameraDisplay();
            
            // Check for intersections
            checkIntersections();
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Initialize immediately
        console.log("Starting initialization...");
        window.onload = function() {
            console.log("Window loaded, initializing...");
            init();
        };
    </script>
</body>
</html>
