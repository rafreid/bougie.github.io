<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOUGIE-3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 200;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #fileInput {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #fileInput input[type="file"] {
            margin-bottom: 10px;
        }
        #fileInput button {
            background-color: #4CAF50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        #fileInput button:hover {
            background-color: #45a049;
        }
        #scrollControls {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #scrollControls button {
            background-color: #2196F3;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
            display: block;
            width: 100%;
            font-size: 14px;
        }
        #scrollControls button:hover {
            background-color: #1976D2;
        }
        #scrollControls button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #timeframeControls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #timeframeControls button {
            background-color: #FF9800;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            font-size: 12px;
        }
        #timeframeControls button:hover {
            background-color: #F57C00;
        }
        #timeframeControls button.active {
            background-color: #4CAF50;
        }
        #timeframeControls button.active:hover {
            background-color: #45a049;
        }
        #patternControls {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 150px;
        }
        #patternControls button {
            background-color: #9C27B0;
            color: white;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px 0;
            display: block;
            width: 100%;
            font-size: 11px;
        }
        #patternControls button:hover {
            background-color: #7B1FA2;
        }
        #patternControls button.active {
            background-color: #4CAF50;
        }
        #patternControls button.active:hover {
            background-color: #45a049;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>BOUGIE-3D</h2>
        <div id="hoverInfo">Hover over a XAUUSD candlesticks to see details</div>
        <div id="cameraInfo" style="margin-top: 10px; font-size: 12px; color: #aaa;">
            <strong>Camera Position:</strong> X: <span id="camX">0.00</span> | Y: <span id="camY">0.00</span> | Z: <span id="camZ">0.00</span><br>
            <strong>Cursor Position:</strong> X: <span id="cursorX">0.00</span> | Y: <span id="cursorY">0.00</span>
        </div>
    </div>
    <div id="loading">Loading data...</div>
    <div id="fileInput">
        <input type="file" id="csvFile" accept=".csv" />
        <button onclick="loadCSVFile()">Load CSV</button>
        <button onclick="loadMockData()">Load Demo Data</button>
        <div style="margin-top: 5px; font-size: 12px;">
            CSV Format: "time",open,high,low,close,volume<br>
            Example: "2025.05.22,05:15",3340.47,3340.52,3338.80,3338.80,341
        </div>
    </div>
    <div id="patternControls">
        <div style="margin-bottom: 5px; font-size: 12px; text-align: center; color: #ccc;">
            Pattern Detection
        </div>
        <button onclick="togglePatternDetection()" id="patternToggle" class="active">Enable Patterns</button>
        <div style="margin: 8px 0; font-size: 10px; color: #888;">
            Detected Patterns:
        </div>
        <button onclick="togglePattern('doji')" id="pattern-doji" class="active">Doji</button>
        <button onclick="togglePattern('hammer')" id="pattern-hammer" class="active">Hammer</button>
        <button onclick="togglePattern('engulfing')" id="pattern-engulfing" class="active">Engulfing</button>
        <button onclick="togglePattern('morningstar')" id="pattern-morningstar" class="active">Morning Star</button>
        <button onclick="togglePattern('eveningstar')" id="pattern-eveningstar" class="active">Evening Star</button>
    </div>
    <div id="scrollControls">
        <button onclick="scrollDataLeft()" id="scrollLeftBtn">◀ Scroll Left</button>
        <button onclick="scrollDataRight()" id="scrollRightBtn">Scroll Right ▶</button>
        <button onclick="resetCamera()" id="resetCameraBtn" style="margin-top: 10px;">Reset Camera</button>
        <div style="margin-top: 10px; font-size: 12px; text-align: center; color: #ccc;">
            Navigate Data
        </div>
    </div>
    <div id="timeframeControls">
        <div style="margin-bottom: 5px; font-size: 12px; text-align: center; color: #ccc;">
            Timeframes
        </div>
        <button onclick="setTimeframe('1m')" id="tf-1m">1m</button>
        <button onclick="setTimeframe('5m')" id="tf-5m" class="active">5m</button>
        <button onclick="setTimeframe('15m')" id="tf-15m">15m</button>
        <button onclick="setTimeframe('1h')" id="tf-1h">1h</button>
        <button onclick="setTimeframe('4h')" id="tf-4h">4h</button>
        <button onclick="setTimeframe('1D')" id="tf-1D">1D</button>
    </div>
    <div id="controls">
        <ul>
            <li>Left click + drag: Rotate camera</li>
            <li>Right click + drag: Pan camera</li>
            <li>Scroll: Zoom in/out</li>
            <li>Hover over candlestick: View details</li>
            <li>Arrow keys: Navigate data left/right</li>
        </ul>
        <p>AFLUX Systems LLC - R. Reid - (C) 2025</p>
    </div>

    <!-- Load Three.js directly from CDN -->
    <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        console.log("Script started");
        
        // Mock data for testing
        const mockData = [
            {"date":"2025-04-24T00:10:22.404Z","open":2000,"high":2032.99,"low":1983.06,"close":2032.02,"volume":7015},
            {"date":"2025-04-25T00:10:22.404Z","open":2032.02,"high":2045.70,"low":1984.90,"close":1997.34,"volume":7913},
            {"date":"2025-04-26T00:10:22.404Z","open":1997.34,"high":2004.64,"low":1986.94,"close":1991.09,"volume":13773},
            {"date":"2025-04-29T00:10:22.404Z","open":1991.09,"high":2032.72,"low":1975.62,"close":2014.10,"volume":14911},
            {"date":"2025-04-30T00:10:22.404Z","open":2014.10,"high":2044.37,"low":2011.90,"close":2028.91,"volume":11910},
            {"date":"2025-05-01T00:10:22.404Z","open":2028.91,"high":2061.74,"low":2014.23,"close":2061.17,"volume":12169},
            {"date":"2025-05-02T00:10:22.404Z","open":2061.17,"high":2072.84,"low":2045.87,"close":2055.54,"volume":7974},
            {"date":"2025-05-03T00:10:22.404Z","open":2055.54,"high":2063.83,"low":2039.32,"close":2039.86,"volume":5867},
            {"date":"2025-05-06T00:10:22.404Z","open":2039.86,"high":2057.15,"low":2014.69,"close":2015.02,"volume":8035},
            {"date":"2025-05-07T00:10:22.404Z","open":2015.02,"high":2061.32,"low":2002.37,"close":2053.60,"volume":10205},
            {"date":"2025-05-08T00:10:22.404Z","open":2053.60,"high":2067.98,"low":2001.08,"close":2020.72,"volume":13691},
            {"date":"2025-05-09T00:10:22.404Z","open":2020.72,"high":2029.68,"low":1985.47,"close":1996.95,"volume":8147},
            {"date":"2025-05-10T00:10:22.404Z","open":1996.95,"high":2002.81,"low":1982.72,"close":1987.52,"volume":12438},
            {"date":"2025-05-13T00:10:22.404Z","open":1987.52,"high":1991.37,"low":1962.07,"close":1976.86,"volume":6736},
            {"date":"2025-05-14T00:10:22.404Z","open":1976.86,"high":2019.25,"low":1976.81,"close":2000.94,"volume":8603},
            {"date":"2025-05-15T00:10:22.404Z","open":2000.94,"high":2008.36,"low":1968.98,"close":1986.90,"volume":10998},
            {"date":"2025-05-16T00:10:22.404Z","open":1986.90,"high":2003.62,"low":1970.32,"close":1974.65,"volume":12213},
            {"date":"2025-05-17T00:10:22.404Z","open":1974.65,"high":2001.48,"low":1971.65,"close":1993.55,"volume":6266},
            {"date":"2025-05-20T00:10:22.404Z","open":1993.55,"high":2008.92,"low":1946.72,"close":1964.24,"volume":13114},
            {"date":"2025-05-21T00:10:22.404Z","open":1964.24,"high":1982.42,"low":1954.73,"close":1963.40,"volume":8770},
            {"date":"2025-05-22T00:10:22.404Z","open":1963.40,"high":1999.26,"low":1960.05,"close":1998.54,"volume":9999},
            {"date":"2025-05-23T00:10:22.404Z","open":1998.54,"high":2016.49,"low":1991.05,"close":2008.28,"volume":14505}
        ];

        // Global variables
        let scene, camera, renderer, controls, raycaster, mouse;
        let candlesticks = [];
        let currentData = [];
        let rawData = []; // Store original unfiltered data
        let scrollOffset = 0; // Track the current scroll position
        let currentTimeframe = '5m'; // Default timeframe
        let patternDetectionEnabled = true;
        let enabledPatterns = {
            doji: true,
            hammer: true,
            engulfing: true,
            morningstar: true,
            eveningstar: true
        };
        let detectedPatterns = []; // Store detected patterns
        
        // Scroll functions
        function scrollDataLeft() {
            console.log("Scroll left clicked, current offset:", scrollOffset);
            if (scrollOffset > 0) {
                scrollOffset--;
                console.log("New offset:", scrollOffset);
                updateCandlestickPositions();
                updateScrollButtons();
            } else {
                console.log("Cannot scroll left further");
            }
        }
        
        function scrollDataRight() {
            console.log("Scroll right clicked, current offset:", scrollOffset);
            if (scrollOffset < currentData.length - 1) {
                scrollOffset++;
                console.log("New offset:", scrollOffset);
                updateCandlestickPositions();
                updateScrollButtons();
            } else {
                console.log("Cannot scroll right further");
            }
        }
        
        function updateCandlestickPositions() {
            console.log("Updating positions with offset:", scrollOffset);
            candlesticks.forEach((candlestick, index) => {
                const newX = index - scrollOffset;
                candlestick.wick.position.x = newX;
                candlestick.body.position.x = newX;
                
                // Also update pattern indicator position if it exists
                if (candlestick.indicator) {
                    candlestick.indicator.position.x = newX;
                }
            });
            
            // Update camera target to follow the center of visible candlesticks
            const centerX = (currentData.length - 1) / 2 - scrollOffset;
            controls.target.set(centerX, 5, 0);
            controls.update();
        }
        
        function updateScrollButtons() {
            const leftBtn = document.getElementById('scrollLeftBtn');
            const rightBtn = document.getElementById('scrollRightBtn');
            
            console.log("Updating button states - offset:", scrollOffset, "data length:", currentData.length);
            
            if (leftBtn && rightBtn) {
                const canScrollLeft = scrollOffset > 0;
                const canScrollRight = scrollOffset < currentData.length - 1;
                
                leftBtn.disabled = !canScrollLeft;
                rightBtn.disabled = !canScrollRight;
            }
        }
        
        // Reset camera to default position
        function resetCamera() {
            console.log("Resetting camera");
            const centerX = (currentData.length - 1) / 2 - scrollOffset;
            camera.position.set(centerX, 10, 20);
            controls.target.set(centerX, 5, 0);
            controls.update();
        }
        
        // Timeframe functions
        function setTimeframe(timeframe) {
            console.log("Setting timeframe to:", timeframe);
            currentTimeframe = timeframe;
            
            // Update UI
            document.querySelectorAll('#timeframeControls button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`tf-${timeframe}`).classList.add('active');
            
            // In a real application, this would filter data based on timeframe
            // For this demo, we'll just reload the mock data
            loadMockData();
        }
        
        // Pattern detection functions
        function togglePatternDetection() {
            patternDetectionEnabled = !patternDetectionEnabled;
            console.log("Pattern detection:", patternDetectionEnabled ? "enabled" : "disabled");
            
            // Update UI
            const btn = document.getElementById('patternToggle');
            if (patternDetectionEnabled) {
                btn.classList.add('active');
                btn.textContent = "Enable Patterns";
            } else {
                btn.classList.remove('active');
                btn.textContent = "Disable Patterns";
            }
            
            // Update visualization
            updatePatternVisibility();
        }
        
        function togglePattern(pattern) {
            enabledPatterns[pattern] = !enabledPatterns[pattern];
            console.log(`Pattern ${pattern}:`, enabledPatterns[pattern] ? "enabled" : "disabled");
            
            // Update UI
            const btn = document.getElementById(`pattern-${pattern}`);
            if (enabledPatterns[pattern]) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            
            // Update visualization
            updatePatternVisibility();
        }
        
        function updatePatternVisibility() {
            // Hide/show pattern indicators based on settings
            candlesticks.forEach(candlestick => {
                if (candlestick.indicator && candlestick.pattern) {
                    const shouldShow = patternDetectionEnabled && enabledPatterns[candlestick.pattern];
                    candlestick.indicator.visible = shouldShow;
                }
            });
        }
        
        // CSV file loading
        function loadCSVFile() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert("Please select a CSV file first.");
                return;
            }
            
            console.log("Loading CSV file:", file.name);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const contents = e.target.result;
                parseCSVData(contents);
            };
            
            reader.readAsText(file);
        }
        
        function parseCSVData(csvText) {
            // Simple CSV parser - in a real application, you would use a more robust solution
            const lines = csvText.split('\n');
            const parsedData = [];
            
            // Skip header row
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const values = line.split(',');
                if (values.length < 6) continue;
                
                // Extract date and time from the first column
                const dateTimeStr = values[0].replace(/"/g, '');
                const [dateStr, timeStr] = dateTimeStr.split(',');
                
                // Create a date object
                const dateParts = dateStr.split('.');
                const timeParts = timeStr ? timeStr.split(':') : ['00', '00'];
                
                const year = parseInt(dateParts[0]);
                const month = parseInt(dateParts[1]) - 1; // JavaScript months are 0-indexed
                const day = parseInt(dateParts[2]);
                const hour = parseInt(timeParts[0]);
                const minute = parseInt(timeParts[1]);
                
                const date = new Date(year, month, day, hour, minute);
                
                parsedData.push({
                    date: date,
                    open: parseFloat(values[1]),
                    high: parseFloat(values[2]),
                    low: parseFloat(values[3]),
                    close: parseFloat(values[4]),
                    volume: parseInt(values[5])
                });
            }
            
            if (parsedData.length === 0) {
                alert("No valid data found in CSV file.");
                return;
            }
            
            console.log("Parsed CSV data:", parsedData);
            
            // Store raw data and update visualization
            rawData = parsedData;
            processData();
        }
        
        // Load mock data
        function loadMockData() {
            console.log("Loading mock data");
            rawData = mockData;
            processData();
        }
        
        // Process data based on current timeframe
        function processData() {
            // In a real application, this would aggregate data based on timeframe
            // For this demo, we'll just use the raw data
            currentData = [...rawData];
            
            // Reset scroll position
            scrollOffset = 0;
            
            // Clear existing candlesticks
            clearCandlesticks();
            
            // Create visualization
            createVisualization(currentData);
            
            // Update scroll buttons
            updateScrollButtons();
            
            // Detect patterns
            detectPatterns();
        }
        
        function clearCandlesticks() {
            // Remove all candlesticks from scene
            candlesticks.forEach(candlestick => {
                scene.remove(candlestick.wick);
                scene.remove(candlestick.body);
                if (candlestick.indicator) {
                    scene.remove(candlestick.indicator);
                }
            });
            
            // Clear array
            candlesticks = [];
        }
        
        // Pattern detection
        function detectPatterns() {
            if (!patternDetectionEnabled || currentData.length < 3) return;
            
            // Clear existing pattern indicators
            candlesticks.forEach(candlestick => {
                if (candlestick.indicator) {
                    scene.remove(candlestick.indicator);
                    candlestick.indicator = null;
                }
                candlestick.pattern = null;
            });
            
            // Detect patterns
            for (let i = 2; i < currentData.length; i++) {
                const current = currentData[i];
                const prev = currentData[i-1];
                const prevPrev = currentData[i-2];
                
                // Doji pattern (open and close are very close)
                if (Math.abs(current.open - current.close) / (current.high - current.low) < 0.1) {
                    createPatternIndicator(i, 'doji', 0xffff00);
                }
                
                // Hammer pattern (long lower shadow, small body at the top)
                const bodySize = Math.abs(current.open - current.close);
                const lowerShadow = Math.min(current.open, current.close) - current.low;
                const upperShadow = current.high - Math.max(current.open, current.close);
                
                if (lowerShadow > 2 * bodySize && upperShadow < 0.5 * bodySize) {
                    createPatternIndicator(i, 'hammer', 0x00ffff);
                }
                
                // Bullish engulfing pattern
                if (prev.close < prev.open && // Previous candle is bearish
                    current.close > current.open && // Current candle is bullish
                    current.open < prev.close && // Current open is lower than previous close
                    current.close > prev.open) { // Current close is higher than previous open
                    createPatternIndicator(i, 'engulfing', 0xff00ff);
                }
                
                // Morning star pattern (three candle pattern)
                if (i >= 2 && 
                    prevPrev.close < prevPrev.open && // First candle is bearish
                    Math.abs(prev.open - prev.close) < (prev.high - prev.low) * 0.3 && // Second candle is small
                    current.close > current.open && // Third candle is bullish
                    current.close > (prevPrev.open + prevPrev.close) / 2) { // Third candle closes above midpoint of first
                    createPatternIndicator(i, 'morningstar', 0x00ff00);
                }
                
                // Evening star pattern (three candle pattern)
                if (i >= 2 && 
                    prevPrev.close > prevPrev.open && // First candle is bullish
                    Math.abs(prev.open - prev.close) < (prev.high - prev.low) * 0.3 && // Second candle is small
                    current.close < current.open && // Third candle is bearish
                    current.close < (prevPrev.open + prevPrev.close) / 2) { // Third candle closes below midpoint of first
                    createPatternIndicator(i, 'eveningstar', 0xff0000);
                }
            }
            
            // Update pattern visibility based on enabled patterns
            updatePatternVisibility();
        }
        
        function createPatternIndicator(index, pattern, color) {
            if (!candlesticks[index]) return;
            
            const candlestick = candlesticks[index];
            candlestick.pattern = pattern;
            
            // Create a star shape above the candlestick
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const indicator = new THREE.Mesh(geometry, material);
            
            // Position above the candlestick
            const x = index - scrollOffset;
            const y = normalizePrice(currentData[index].high) + 0.5;
            indicator.position.set(x, y, 0);
            
            scene.add(indicator);
            candlestick.indicator = indicator;
            
            // Set visibility based on pattern settings
            indicator.visible = patternDetectionEnabled && enabledPatterns[pattern];
        }
        
        // Initialize the scene
        function init() {
            console.log("Initializing scene...");
            
            // Check if THREE is available
            if (typeof THREE === 'undefined') {
                console.error("THREE is not defined! Script loading issue.");
                document.getElementById('loading').textContent = 'Error: THREE.js not loaded';
                return;
            }
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 15);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add grid for reference
            const gridHelper = new THREE.GridHelper(50, 50, 0x555555, 0x333333);
            scene.add(gridHelper);
            
            // Add axes for reference
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // Check if OrbitControls is available
            if (typeof THREE.OrbitControls === 'undefined') {
                console.error("THREE.OrbitControls is not defined! Script loading issue.");
                document.getElementById('loading').textContent = 'Error: OrbitControls not loaded';
                return;
            }
            
            // Add orbit controls for interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Setup raycaster for hover interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle mouse move for hover effects
            window.addEventListener('mousemove', onMouseMove);
            
            // Handle keyboard navigation
            window.addEventListener('keydown', onKeyDown);
            
            // Use mock data
            loadMockData();
            
            // Hide loading message
            document.getElementById('loading').style.display = 'none';
            
            // Start animation loop
            animate();
        }
        
        // Handle keyboard navigation
        function onKeyDown(event) {
            switch(event.key) {
                case 'ArrowLeft':
                    scrollDataLeft();
                    break;
                case 'ArrowRight':
                    scrollDataRight();
                    break;
            }
        }
        
        // Create 3D visualization from stock data
        function createVisualization(data) {
            console.log("Creating visualization with data:", data);
            
            // Find min and max values for scaling
            minPrice = Infinity;
            maxPrice = -Infinity;
            let minVolume = Infinity;
            let maxVolume = -Infinity;
            
            data.forEach(day => {
                minPrice = Math.min(minPrice, day.low);
                maxPrice = Math.max(maxPrice, day.high);
                minVolume = Math.min(minVolume, day.volume);
                maxVolume = Math.max(maxVolume, day.volume);
            });
            
            priceRange = maxPrice - minPrice;
            
            console.log("Price range:", minPrice, "to", maxPrice);
            console.log("Volume range:", minVolume, "to", maxVolume);
            
            // Create base platform
            const platformGeometry = new THREE.BoxGeometry(data.length + 2, 0.5, 15);
            const platformMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(data.length / 2 - 0.5, -0.25, 0);
            platform.receiveShadow = true;
            scene.add(platform);
            
            // Create price axis labels
            createPriceAxis(minPrice, maxPrice);
            
            // Create date axis labels
            createDateAxis(data);
            
            // Create candlesticks
            data.forEach((day, index) => {
                // Normalize price values
                const normalizedOpen = normalizePrice(day.open);
                const normalizedClose = normalizePrice(day.close);
                const normalizedHigh = normalizePrice(day.high);
                const normalizedLow = normalizePrice(day.low);
                
                // Normalize volume
                const volumeRange = maxVolume - minVolume;
                const normalizedVolume = ((day.volume - minVolume) / volumeRange) * 3 + 0.5;
                
                // Create candlestick
                const isUp = day.close >= day.open;
                const candleColor = isUp ? 0x00ff00 : 0xff0000;
                
                // Create wick (vertical line)
                const wickGeometry = new THREE.CylinderGeometry(0.05, 0.05, normalizedHigh - normalizedLow, 8);
                const wickMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                const wick = new THREE.Mesh(wickGeometry, wickMaterial);
                wick.position.set(index - scrollOffset, (normalizedHigh + normalizedLow) / 2, 0);
                wick.castShadow = true;
                scene.add(wick);
                
                // Create body (box)
                const bodyHeight = Math.abs(normalizedClose - normalizedOpen);
                const bodyGeometry = new THREE.BoxGeometry(0.6, bodyHeight, normalizedVolume);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: candleColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                // Position body
                const bodyY = isUp ? 
                    (normalizedOpen + bodyHeight / 2) : 
                    (normalizedClose + bodyHeight / 2);
                body.position.set(index - scrollOffset, bodyY, 0);
                body.castShadow = true;
                scene.add(body);
                
                // Store reference to candlestick for interaction
                candlesticks.push({
                    wick: wick,
                    body: body,
                    data: day,
                    pattern: null,
                    indicator: null
                });
            });
            
            // Position camera to view all candlesticks
            resetCamera();
        }
        
        // Normalize price to visualization scale
        function normalizePrice(price) {
            return ((price - minPrice) / priceRange) * 10;
        }
        
        // Create price axis labels
        function createPriceAxis(minPrice, maxPrice) {
            const priceRange = maxPrice - minPrice;
            const labelCount = 5;
            
            for (let i = 0; i <= labelCount; i++) {
                const price = minPrice + (priceRange * i / labelCount);
                const normalizedY = (i / labelCount) * 10;
                
                // Create line marker
                const markerGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.1);
                const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(-1, normalizedY, 0);
                scene.add(marker);
                
                // Create text sprite for price label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                context.fillStyle = '#ffffff';
                context.font = '24px Arial';
                context.fillText('$' + price.toFixed(2), 0, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(-3, normalizedY, 0);
                sprite.scale.set(3, 1.5, 1);
                scene.add(sprite);
            }
        }
        
        // Create date axis labels
        function createDateAxis(data) {
            // Add labels for every 5th day
            for (let i = 0; i < data.length; i += 5) {
                if (i < data.length) {
                    const date = new Date(data[i].date);
                    const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;
                    
                    // Create text sprite for date label
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 64;
                    canvas.height = 32;
                    context.fillStyle = '#ffffff';
                    context.font = '16px Arial';
                    context.fillText(dateStr, 0, 20);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.set(i - scrollOffset, -1, 0);
                    sprite.scale.set(2, 1, 1);
                    scene.add(sprite);
                }
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle mouse move for hover effects
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update cursor position display
            document.getElementById('cursorX').textContent = mouse.x.toFixed(2);
            document.getElementById('cursorY').textContent = mouse.y.toFixed(2);
        }
        
        // Check for intersections with candlesticks
        function checkIntersections() {
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Collect all meshes for intersection test
            const meshes = candlesticks.flatMap(candlestick => [candlestick.wick, candlestick.body]);
            
            // Calculate intersections
            const intersects = raycaster.intersectObjects(meshes);
            
            // Reset all candlesticks to original appearance
            candlesticks.forEach(candlestick => {
                const isUp = candlestick.data.close >= candlestick.data.open;
                candlestick.body.material.color.setHex(isUp ? 0x00ff00 : 0xff0000);
                candlestick.body.material.opacity = 1;
                candlestick.wick.material.color.setHex(0xcccccc);
            });
            
            // Update hover info text
            const hoverInfoElement = document.getElementById('hoverInfo');
            
            if (intersects.length > 0) {
                // Find which candlestick was intersected
                const intersectedMesh = intersects[0].object;
                const candlestick = candlesticks.find(c => 
                    c.wick === intersectedMesh || c.body === intersectedMesh
                );
                
                if (candlestick) {
                    // Highlight the intersected candlestick
                    candlestick.body.material.color.setHex(0xffff00);
                    candlestick.wick.material.color.setHex(0xffff00);
                    
                    // Format date
                    const date = new Date(candlestick.data.date);
                    const dateStr = date.toLocaleDateString();
                    
                    // Update info text
                    hoverInfoElement.innerHTML = `
                        <strong>Date:</strong> ${dateStr}<br>
                        <strong>Open:</strong> $${candlestick.data.open.toFixed(2)}<br>
                        <strong>High:</strong> $${candlestick.data.high.toFixed(2)}<br>
                        <strong>Low:</strong> $${candlestick.data.low.toFixed(2)}<br>
                        <strong>Close:</strong> $${candlestick.data.close.toFixed(2)}<br>
                        <strong>Volume:</strong> ${candlestick.data.volume.toLocaleString()}
                    `;
                    
                    // Show pattern info if available
                    if (candlestick.pattern) {
                        hoverInfoElement.innerHTML += `<br><strong>Pattern:</strong> ${candlestick.pattern}`;
                    }
                }
            } else {
                // Reset info text when not hovering over any candlestick
                hoverInfoElement.textContent = 'Hover over a XAUUSD candlesticks to see details';
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Check for intersections
            checkIntersections();
            
            // Update camera position display
            document.getElementById('camX').textContent = camera.position.x.toFixed(2);
            document.getElementById('camY').textContent = camera.position.y.toFixed(2);
            document.getElementById('camZ').textContent = camera.position.z.toFixed(2);
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Initialize the application when the page is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM fully loaded, starting application...");
            init();
        });
    </script>
</body>
</html>
